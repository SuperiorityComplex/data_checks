- being able to connect any database to schema
- silencing alerts and reminder in X days, minutes, hours, etc.
- Versioning
- Skippable / Dont run alerts conditional
- Aggregation of total, status, messages by category
- Search through metadata for insights
- Temporal Look at Checks (i.e. history of success and failures)
- Filters for statuses, categories, and metadata
- Severity of error
- Readable name, category, name, rule_name, additional_features, created_at, finished_at, status, message, metadata
- defining functions that can be run before and after save, defining additional properties for model
- data values at the time of the error (i.e. parameters)
- unique id
- assigning to users
- transforms on dataset object

Check + Suites
- tags on checks and suites
- description on tag and suites
- excluded rules, checks
- Storing static string of suite and check
// - Scheduled runs
// - Execution started, ended, status, logs
// - Alerting
// - Number of occurences before alert is triggered

# panda-patrol

### WIP
[x] suites
[ ] GE integration


[ ] roadmap
### Lower Priority
[ ] rules_context without decorator (with comments)
[ ] streaming database
[ ] anomaly detection
[ ] pretty printing
[ ] frontend
[ ] data profiling
[ ] deployment
[ ] wrap assertions for printing
[ ] did you mean suggestions for when user mistypes check name
[ ] silencing alerts and reminder in X days, minutes, hours, etc.
- Go from notebook to check
    [ ] check.init => name, etc
    [ ] rule.start() => rule.end()
    [ ] generate_base_file(overwrite)
- @params, ingestor (caching)
- pause check, silencing check
- depends on pipeline
- alerting
- versioning
- rule without self
- Alphabetical order for rules and checks running
- deal with writting large data frames to database
- capturing other exceptions
- Skipping rules